class QuantumCohomologyPartialFlagVariety:
    def __init__(self, dynkin, parabolic, base=QQ):
        # think about which ones are eventually used, and which ones are not
        self.root_system = RootSystem(CartanType(dynkin)).root_lattice()
        self.weyl_group = self.root_system.weyl_group(prefix="s")

        self.parabolic = tuple(parabolic)
        self.nonparabolic = tuple([j for j in CartanType(dynkin).index_set() if j not in parabolic])

        # Novikov ring for the small quantum cohomology
        self.coefficients = PolynomialRing(base, ["q%d" % i for i in K])

        # the underlying module of quantum cohomology over the Novikov ring, freely generated by Schubert classes
        # TODO use precomputed values here?
        schubert = list(set([w.coset_representative(self.nonparabolic) for w in self.weyl_group]))
        self.module = CombinatorialFreeModule(self.coefficients, schubert)


    def quantum_chevalley(self, divisor, element):
        r"""
        Quantum Chevalley formula

        This encodes the quantum multiplication of an element in the quantum cohomology of a
        partial flag variety by a divisor class.

        The formula is given in Theorem 10.1 of [MR2072765].

        [MR2072765] Fulton--Woodward, On the quantum product of Schubert classes,
        J. Algebraic Geom. 13 (2004), no. 4, 641â€“661.

        INPUT:

        - ``divisor``: the divisor class we are multiplying with this can be either an appropriate
          element of ``self.module`` or a parabolic simple root, or an integer specifying the
          simple parabolic root

        - ``element`` -- element of self.module: the element we are multiplying

        OUTPUT: the result of quantum multiplication, as an element of ``self.module``

        EXAMPLES:

        """
        def h(alpha, beta):
            r"""
            Helper function: coefficient of 

            Is there a more intrinsic way of doing this?

            See definition preceding Lemma 3.1 in [MR2072765].
            """
            parabolic_simple_roots = [self.root_system.simple_root(k) for k in self.parabolic]
            assert beta in parabolic_simple_roots, "need a parabolic simple root"

            # determine the coefficient n_{\alpha\beta}
            n = sum([a*b for (a, b) in zip(alpha.dense_coefficient_list(), beta.dense_coefficient_list())])

            alpha = alpha.to_ambient()
            beta = beta.to_ambient()

            return n * beta.inner_product(beta) / alpha.inner_product(alpha)

        def degree(alpha):
            r"""
            Helper function: degree of first Chern class of G/P on Schubert class given by ``alpha``

            This is the content of Lemma 3.5 of [MR2072765]
            """
            rho = sum(self.root_system.nonparabolic_positive_roots(self.nonparabolic))

            rho = rho.to_ambient()
            alpha = alpha.to_ambient()

            return 2 * rho.inner_product(alpha) / alpha.inner_product(alpha)

        # if divisor is an integer we interpret it as the index of a parabolic simple root
        if ZZ.is_parent_of(divisor) or isinstance(divisor, int):
            assert divisor in self.parabolic, "index needs to specify a parabolic simple root"

            return self.quantum_chevalley(self.root_system.simple_root(divisor), element)

        # if divisor is entry of quantum cohomology: make sure it's a sum of divisors, and then compute it for that
        if self.module.is_parent_of(divisor):
            assert all(map(lambda d: d.length() == 1, divisor.support())), "need a divisor, not a general element"

            return sum([monomial.leading_coefficient() * self.quantum_chevalley(monomial.leading_support().reflection_to_root(), element) for monomial in divisor.terms()])

        # if divisor is element in the Weyl group: check it's a simple reflection
        if self.weyl_group.is_parent_of(divisor):
            assert divisor in [self.weyl_group.simple_reflection(k) for k in self.parabolic], "need a divisor"

            return self.chevalley(divisor.reflection_to_root(), element)

        # at this point divisor must refer to a parabolic simple root
        parabolic_simple_roots = [self.root_system.simple_root(k) for k in self.parabolic]
        assert self.root_system.is_parent_of(divisor) and divisor in parabolic_simple_roots, \
            "divisor must be a parabolic simple root"

        # if the element is zero we are done
        if element.is_zero():
            return self.module.zero()

        # if the element is a sum of at least two monomials we recurse
        if len(element.monomials()) > 1:
            monomial = element.leading_monomial_term()
            return self.chevalley(divisor, monomial) + self.chevalley(divisor, element - monomial)

        # we are in the setup of the formula: apply quantum Chevalley to the Schubert class \sigma_u
        u = element.leading_support()

        # we will separate the classical and quantum contributions in case that's ever useful
        classical = self.module.zero()
        quantum = self.module.zero()

        # the quantum Chevalley formula
        for alpha in self.root_system.nonparabolic_positive_roots(self.nonparabolic):
            # converting a root alpha into the correponding element reflection in the Weyl group
            reflection = self.weyl_group.from_reduced_word(alpha.associated_reflection())
            # Schubert class associated to the coset u * s_\alpha
            v = (u * reflection).coset_representative(self.nonparabolic)

            if v.length() == u.length() + 1:
                classical = classical + h(alpha, divisor) * self.module(v)

            if v.length() == u.length() + 1 - degree(alpha):
                coefficient = product([self.coefficients.gen(j)^(h(alpha, beta)) for (j, beta) in enumerate(parabolic_simple_roots)])
                quantum = quantum + coefficient * h(alpha, divisor) * self.module(v)

        return element.leading_coefficient() * (classical + quantum)


    def quantum_spectrum(self):
        # determine canonical divisor

        # determine the matrix

        # specialise

        # compute eigenvalues

        return []
