r"""
Implementation of (small) quantum cohomology algebra of a partial flag variety

This provides a set of tools to manipulate the (small) quantum cohomology algebra
of a partial flag variety. A partial flag variety is the quotient of a reductive
algebraic group by a parabolic subgroup, and quantum cohomology is a certain deformation
of the usual cohomology algebra, where structure coefficients are given by Gromov-Witten
invariants.

EXAMPLES::

<Lots and lots of examples>

AUTHORS:

- Maxim Smirnov (2021-01-25): initial version

- Pieter Belmans (2021-03-30): flexible implementation and documentation

"""

# ****************************************************************************
#       Copyright (C) 2013 Maxim Smirnov <maxim.smirnov@math.uni-augsburg.de>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#                  https://www.gnu.org/licenses/
# ****************************************************************************

class QuantumCohomologyPartialFlagVariety:
    def __init__(self, dynkin, parabolic, base=QQ):
        r"""
        The quantum cohomology of a partial flag variety.

        INPUT:

        - ``dynkin`` -- Dynkin label
        - ``parabolic`` -- tuple giving subset of simple roots defined by the Dynkin label
        - ``base`` -- (optional) coefficient ring for the quantum cohomology

        To get the maximal parabolic ``P_k`` associated to a vertex ``k`` in the Dynkin
        diagram one takes parabolic to be the singleton ``(k,)``

        EXAMPLES::

            sage: QH = QuantumCohomologyPartialFlagVariety("A2", (1,))
            sage: QH = QuantumCohomologyPartialFlagVariety("B3", (1,2))
            sage: QH = QuantumCohomologyPartialFlagVariety("D4", (1,2,3,4))

        """
        # these would be better as getters and setters?
        self.root_system = RootSystem(CartanType(dynkin))
        self.root_lattice = self.root_system.root_lattice()
        self.weyl_group = self.root_lattice.weyl_group(prefix="s")

        self.parabolic = tuple(sorted(set(parabolic)))
        assert set(self.parabolic).issubset(self.root_system.index_set()), \
                "parabolic subgroup must be specified by a subset of the index set of the root system"
        self.nonparabolic = tuple([j for j in CartanType(dynkin).index_set() if j not in parabolic])

        # Novikov ring for the small quantum cohomology
        self.coefficients = PolynomialRing(base, ["q%d" % i for i in self.parabolic])

        # the underlying module of quantum cohomology over the Novikov ring, freely generated by Schubert classes
        self.schubert_basis = list(set([w.coset_representative(self.nonparabolic) for w in self.weyl_group]))
        self.schubert_basis = sorted(self.schubert_basis, key=lambda s: s.length())
        self.module = CombinatorialFreeModule(self.coefficients, self.schubert_basis)
        self.divisors = [self.module.monomial(self.weyl_group.gen(k-1)) for k in self.parabolic]


    def __repr__(self):
        """Description of the quantum cohomology algebra"""
        return "Quantum cohomology algebra for %s / P_%s: \n%s" % \
                (self.root_system.cartan_type(), self.parabolic, self.root_system.dynkin_diagram())


    def quantum_chevalley(self, divisor, element):
        r"""
        Quantum Chevalley formula

        Compute the quantum multiplication of an element in the quantum cohomology of a
        partial flag variety by a divisor class.

        The formula is given in Theorem 10.1 of [MR2072765].

        [MR2072765] Fulton--Woodward, On the quantum product of Schubert classes,
        J. Algebraic Geom. 13 (2004), no. 4, 641â€“661.

        INPUT:

        - ``divisor`` -- the divisor class we are multiplying with this can be either an appropriate
          element of ``self.module`` or a parabolic simple root, or an integer specifying the
          simple parabolic root

        - ``element`` -- element of self.module: the element we are multiplying

        OUTPUT: the result of quantum multiplication, as an element of ``self.module``

        EXAMPLES::

        Some computations in the quantum cohomology of P^3::

            sage: QH = QuantumCohomologyPartialFlagVariety("A3", (1,))
            sage: QH.quantum_chevalley(1, QH.module.monomial(QH.schubert_basis[0]))
            B[s1]
            sage: QH.quantum_chevalley(QH.divisors[0], QH.module.monomial(QH.schubert_basis[0]))
            B[s1]
            sage: QH.quantum_chevalley(1, QH.module.monomial(QH.schubert_basis[3]))
            q1*B[1]

        A non-trivial computation in the quantum cohomology of the orthogonal Grassmannian OGr(2,8)::

            sage: QH = QuantumCohomologyPartialFlagVariety("D4", (2,))
            sage: QH.quantum_chevalley(2, QH.module.basis().list()[9])
            B[s4*s2*s3*s1*s2] + B[s3*s2*s4*s1*s2] + 2*B[s2*s4*s3*s1*s2] + B[s1*s2*s4*s3*s2] + q2*B[1]
        """
        def h(alpha, beta):
            r"""
            Helper function: coefficient of beta in Schubert basis expansion for alpha

            See definition preceding Lemma 3.1 in [MR2072765].
            """
            parabolic_simple_roots = [self.root_lattice.simple_root(k) for k in self.parabolic]
            assert beta in parabolic_simple_roots, "need a parabolic simple root"

            # determine the coefficient n_{\alpha\beta}
            n = sum([a*b for (a, b) in zip(alpha.dense_coefficient_list(), beta.dense_coefficient_list())])

            alpha = alpha.to_ambient()
            beta = beta.to_ambient()

            return n * beta.inner_product(beta) / alpha.inner_product(alpha)

        def degree(alpha):
            r"""
            Helper function: degree of first Chern class of G/P on Schubert class given by ``alpha``

            This is the content of Lemma 3.5 of [MR2072765]
            """
            rho = sum(self.root_lattice.nonparabolic_positive_roots(self.nonparabolic))

            rho = rho.to_ambient()
            alpha = alpha.to_ambient()

            return 2 * rho.inner_product(alpha) / alpha.inner_product(alpha)

        # if divisor is an integer we interpret it as the index of a parabolic simple root
        if ZZ.is_parent_of(divisor) or isinstance(divisor, int):
            assert divisor in self.parabolic, "index needs to specify a parabolic simple root"

            return self.quantum_chevalley(self.root_lattice.simple_root(divisor), element)

        # if divisor is entry of quantum cohomology: make sure it's a sum of divisors, and then compute it for that
        if self.module.is_parent_of(divisor):
            assert all(map(lambda d: d.length() == 1, divisor.support())), "need a divisor, not a general element"

            return sum([monomial.leading_coefficient() * self.quantum_chevalley(monomial.leading_support().reflection_to_root(), element) for monomial in divisor.terms()])

        # if divisor is element in the Weyl group: check it's a simple reflection
        if self.weyl_group.is_parent_of(divisor):
            assert divisor in [self.weyl_group.simple_reflection(k) for k in self.parabolic], "need a divisor"

            return self.quantum_chevalley(divisor.reflection_to_root(), element)

        # at this point divisor must refer to a parabolic simple root
        parabolic_simple_roots = [self.root_lattice.simple_root(k) for k in self.parabolic]
        assert self.root_lattice.is_parent_of(divisor) and divisor in parabolic_simple_roots, \
            "divisor must be a parabolic simple root"

        # if the element is zero we are done
        if element.is_zero():
            return self.module.zero()

        # if the element is a sum of at least two monomials we recurse
        if len(element.monomials()) > 1:
            monomial = element.leading_coefficient() * element.leading_monomial()
            return self.quantum_chevalley(divisor, monomial) + self.quantum_chevalley(divisor, element - monomial)

        # we are in the setup of the formula: apply quantum Chevalley to the Schubert class \sigma_u
        u = element.leading_support()

        # we will separate the classical and quantum contributions in case that's ever useful
        classical = self.module.zero()
        quantum = self.module.zero()

        # the quantum Chevalley formula
        for alpha in self.root_lattice.nonparabolic_positive_roots(self.nonparabolic):
            # converting a root alpha into the correponding element reflection in the Weyl group
            reflection = self.weyl_group.from_reduced_word(alpha.associated_reflection())
            # Schubert class associated to the coset u * s_\alpha
            v = (u * reflection).coset_representative(self.nonparabolic)

            if v.length() == u.length() + 1:
                classical = classical + h(alpha, divisor) * self.module(v)

            if v.length() == u.length() + 1 - degree(alpha):
                coefficient = product([self.coefficients.gen(j)^(h(alpha, beta)) for (j, beta) in enumerate(parabolic_simple_roots)])
                quantum = quantum + coefficient * h(alpha, divisor) * self.module(v)

        return element.leading_coefficient() * (classical + quantum)


    def quantum_chevalley_matrix(self, divisor):
        r"""
        Return the matrix of quantum multiplication by ``divisor`` in the Schubert basis

        EXAMPLES::

            sage: QH = QuantumCohomologyPartialFlagVariety("A2", (1,))
            sage: QH.quantum_chevalley_matrix(1)
            [ 0  1  0]
            [ 0  0  1]
            [q1  0  0]

        """
        M = [self.quantum_chevalley(divisor, element) for element in self.module.basis()]

        return matrix(self.module.dimension(), lambda i, j: M[i].coefficient(self.schubert_basis[j]))


    def anticanonical(self):
        """Return the anticanonical divisor as an element of the underlying module.

        EXAMPLES::

        For the projective plane we have ``-K=3H``, as evidenced by::

            sage: QH = QuantumCohomologyPartialFlagVariety("A2", (1,))
            sage: QH.anticanonical()
            3*B[s1]
        """
        weight_lattice = self.root_system.weight_lattice()
        anticanonical_weight = weight_lattice.nonparabolic_positive_root_sum(self.nonparabolic)
        coefficients = [anticanonical_weight.coefficient(k) for k in self.parabolic]

        return sum([c*d for (c, d) in zip(coefficients, self.divisors)])


    def quantum_spectrum(self):
        r"""
        Return the quantum spectrum

        This is the spectrum of the quantum multiplication by the anticanonical divisor,
        which plays an important role in homological mirror symmetry.

        EXAMPLES::

        This example computes the quantum spectrum of the projective plane, which is
        the 3rd roots of unity (multiplied by 3, as the index is 3)::

            sage: QH = QuantumCohomologyPartialFlagVariety("A2", (1,))
            sage: QH.quantum_spectrum()
            [3, -1.5000000000000000? - 2.598076211353316?*I, -1.5000000000000000? + 2.598076211353316?*I]

        """
        M = self.quantum_chevalley_matrix(self.anticanonical())

        # specialise by setting all quantum parameters equal to 1
        M = M.substitute({q:1 for q in self.coefficients.gens()})
        M = M.change_ring(ZZ)

        return M.eigenvalues()
